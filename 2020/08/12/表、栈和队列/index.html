<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="大道至简"><title>数据结构————表、栈和队列 | 岳争</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构————表、栈和队列</h1><a id="logo" href="/.">岳争</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构————表、栈和队列</h1><div class="post-meta">2020-08-12<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="post-content"><meta name="referrer" content="no-referrer"/>

<h1 id="表、栈和队列"><a href="#表、栈和队列" class="headerlink" title="表、栈和队列"></a>表、栈和队列</h1><p><img src="http://pic.netbian.com/uploads/allimg/200618/005100-1592412660d6f4.jpg"></p>
<h2 id="一、抽象数据类型"><a href="#一、抽象数据类型" class="headerlink" title="一、抽象数据类型"></a>一、抽象数据类型</h2><p>&emsp;&emsp;<strong>抽象数据类型</strong>(abstract data type，<strong>ADT</strong>)是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象；例如表、集合、图以及他们各自的操作一起形成的这些对象都可以被看作抽象数据类型，就像整数、实数、布尔数都是数据类型一样。整数、实数和布尔数各自都有与之间相关的操作，而抽象数据类型也是如此。对于集合ADT，可以有像添加(add)、删除(delete)以及包含(contain)这样一些操作。</p>
<h2 id="二、表"><a href="#二、表" class="headerlink" title="二、表"></a>二、表</h2><h3 id="2-1-表的基础"><a href="#2-1-表的基础" class="headerlink" title="2.1 表的基础"></a>2.1 表的基础</h3><p>&emsp;&emsp;我们处理形如A0,A1,A2，···A(N-1)的一般的表。我们说这个表的大小是N。我们将大小为0的特殊的表称为<strong>空表</strong>(empty list)。</p>
<p>&emsp;&emsp;对于除空表外的任何表，我们说Ai后继A(i-1)，并称A(i-1)前驱Ai(i&gt;0)。表中第一个元素为A0，而最后一个元素为是A(N-1)。我们将不定义A0的前驱元，也不定义A(N-1)的后驱元。元素Ai在表中的位置为i+1.</p>
<p>&emsp;&emsp;与这些定义相关的是要在表ADT上进行操作的集合。printList和makeEmpty是常用的操作，其功能显而易见；find返回某一项首次出现的位置；insert和remove一般是从表的某个位置插入和删除某个元素；而fubdKth则返回某个位置上的元素。如果11，22，33，44，55是一个表，则find(22)则会返回1；insert(x，1)可能把表变成11，x，22，33，44，55；而remove(55)则又将该表变成11，x，22，33，44</p>
<h3 id="2-2-表的简单数组实现"><a href="#2-2-表的简单数组实现" class="headerlink" title="2.2 表的简单数组实现"></a>2.2 表的简单数组实现</h3><p>&emsp;&emsp;对于表的这些操作都可以使用数组来实现。虽然数组是由固定的容量创建的，但是在需要的适合我们可以使用双倍的容量创建一个不同的数组。它解决由于使用数组而产生的最严重的问题，可以说是为了使用一个数组，需要对表的大小进行估计，而这种估计对于现在的Java语言是不需要的。下面一段程序解释了一个数组arr在必要的时候是如何被扩容的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">....</span><br><span class="line"><span class="comment">// 经过一些操作后我们发现我们使用的数组容量不够，需要扩容</span></span><br><span class="line">   <span class="keyword">int</span> [] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">       newArr[i] = arr[i];</span><br><span class="line">   &#125;</span><br><span class="line">arr = newArr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font size = 3>使用数组的实现复杂度的问题</font></p>
</blockquote>
<p>&emsp;&emsp;数组的实现可以使得printList以线性时间被执行，而findKth操作则花费常数时间。不过，数组的插入和删除操作缺要花费非常大的开销，这要看插入和删除的位置。最坏的情况下是在数组的头部添加和删除，这样头部以后的所有元素都要向前或者向后移动一个位置，因此这中最坏情况的时间复杂度为O(N)。如果这两种操作都发生在数组的尾部，则只需要花费O(1)的时间。</p>
<h3 id="2-3-表的简单链表实现"><a href="#2-3-表的简单链表实现" class="headerlink" title="2.3 表的简单链表实现"></a>2.3 表的简单链表实现</h3><blockquote>
<p><font size = 3>链表的基础知识</font></p>
</blockquote>
<p>&emsp;&emsp;<strong>链表</strong>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针连接次序实现的。链表由一系列节点组成(链表中每一个元素称为节点)，节点可以在运行时动态生成。每个节点包括两个：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域。</p>
<p><img src="https://i0.hdslb.com/bfs/album/53f0e407bcfb7964c8f1a6f53e46dc0bef3e368e.png"></p>
<blockquote>
<p><font size = 3>链表实现</font></p>
</blockquote>
<p>&emsp;&emsp;链表由一系列节点组成，这些节点不必再内存中相连，每一个节点均含由表元素和到包含该元素后继元的节点的链(link)。我们称之为next链。最后一个单元的next链引用null。</p>
<blockquote>
<p><font size = 3>使用链表实现的复杂度的问题</font></p>
</blockquote>
<p>&emsp;&emsp;为了执行printList或find(x)，只要从表的第一个节点开始，然后用一些后继的next链遍历该表即可。findKth操作不如数组实现的效率要搞，findKth(i)花费的时间为O(i)，并以明显的遍历链表的方式完成，而数组则是O(1)。</p>
<p>&emsp;&emsp;remove则是通过修改next引用来实现，下面的图即给出将第三个元素删除时的示例：</p>
<p><img src="https://i0.hdslb.com/bfs/album/97a3cdd5b5a66f4c2b4f55771dac4050b4ecb920.png"></p>
<p>&emsp;&emsp;insert方法需要使用new操作符从系统取得一个新节点，此后执行两次引用的跳转，其一般想法如下图：</p>
<p><img src="https://i0.hdslb.com/bfs/album/c2fdf9740a8fc04056db9a06ee24972da5f3b822.png"></p>
<p>&emsp;&emsp;在这种链表中前端添加项或删除第一项的特性情形下我们也属于常数时间的操作，当前要假设到链表前端的链是存在的。但是我们如果要在链表的末端添加或者删除操作这种特殊情形就非常的浪费时间，因为我们要从头部开始遍历整个链表来得到尾部的链。这时我也就需要一种升级版的链表，双向链表，这样我们就可解决这种尾端插入或者删除的时间复杂度问题，好处当然不仅仅于此，当我们查找一个指定位置的元素是可以判断它位于链表中的位置是靠进尾部还是更靠近头部，这样我们就可以选择头部开始遍历或者尾部开始遍历，这也是一种节省效率的方式。</p>
<p><img src="https://i0.hdslb.com/bfs/album/fce9c833e64850dc7d26bc82364abc071095fb2d.png"></p>
<h3 id="2-4-Java-Collections-API中的表"><a href="#2-4-Java-Collections-API中的表" class="headerlink" title="2.4 Java Collections API中的表"></a>2.4 Java Collections API中的表</h3><p>&emsp;&emsp;在类库中，Java语言包含一些普通数据结构的实现。该语言的这一部分叫作<strong>Collections API</strong>。表ADT是在Collections API中实现的数据结构之一。</p>
<blockquote>
<p> <font size = 3>Collecation接口</font>        </p>
</blockquote>
<p>&emsp;&emsp;Collections API位于java.util包中，集合(collerction)的概念在Collection接口中得到抽象，它存储一组类型相同的对象。</p>
<p>&emsp;&emsp;在Collection接口中许多方法的功能由他们的名字就可以看出，例如size返回集合中元素的个数、isEmpty返回集合是否为空、add和remove从集合中添加和删除元素等。</p>
<p>&emsp;&emsp;Collection接口扩展了Iterable接口。实现了Iterable接口的类可以拥有增强for循环，该循环属于这些类之上以观察他们所有的项。例如下面的代码，可以用来打印任意集合中的所有项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Collection&lt;String&gt; coll)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String item : coll) &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font size = 3>Iterator接口</font></p>
</blockquote>
<p>&emsp;&emsp;实现Iterable接口的集合必须提供一个称为iterator的方法，该方法返回一个Iterator类型的对象。该Iterator是一个在java.util包中定义的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Iterator接口的思路是，通过iterator方法，每个集合均可创建并返回给客户一个实现Iterator接口的对象，并且当前位置的概念在对象内部存储下来。</p>
<p>&emsp;&emsp;每次调用next方法都会给出集合的下一项。因此，第一次调用next给出第一项，第二次调用给出第二项等等。hasNaext方法用来高数是否存在下一项。当百年一起见到一个正在用于Iterable的对象的增强for循环的时候，它用对Iterator方法的那些调用代替增强for循环得到一个Iterator对象，然后调用next和hasNext。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Collection&lt;String&gt; coll)</span></span>&#123;</span><br><span class="line">	Iterator&lt;String&gt; itr = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span>(itr.hasNext)&#123;</span><br><span class="line">        String item = itr.next();</span><br><span class="line">        System.out.print(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于Iterator接口中的现有方法有限。因此，很难使用Iterator做简单遍历Collection以外的任何操作。Iterator接口还有一个叫作remove的方法，可以删除由next最新返回的元素。虽然Collection接口也包含了一个remove方法，但是，使用Iterator的remove方法会有更多的优点。</p>
<p>&emsp;&emsp;Iterator方法的主要优点在于：Collection的remove方法必须首先找出被删除的项。如果知道所要删除的项的准确位置，那么删除它的开销可能要小很多。如果要在集合中每隔一个元素删除一个项，这时，使用迭代器(Iterator)很容易编写，而且比用Collection的remove方法有着更高的效率！</p>
<p>&emsp;&emsp;当使用Iterator时，重要的时要记住一个基本法则：如果对正在被迭代的集合进行结构上的改变，也就是添加删除等操作。那么迭代器就不再合法，会派出Concurrent-ModificationException异常！为了避免迭代器准备给出某一项作为下一项而该项此后或者被删除，或者也许一个新的项正好插入该项的前面的这样的情形。这意味着，只有在需要立即使用一个迭代器的时候，我们才应该获取迭代器。然而，如果使用了迭代器调用了它自己的remove方法，那么迭代器就仍然是合法的，这是又是我们更愿意使用迭代器的remove方法的原因之一。</p>
<blockquote>
<p><font size = 3>List接口、ArrayList类和LinkedList类</font></p>
</blockquote>
<p>&emsp;&emsp;List继承了Collection接口，因此它包含Collection接口的所有方法，外加其他一些方法。其中最常用的就是get、set、add和remove方法。</p>
<p>&emsp;&emsp;get和set方法使得用户可以访问或者改变通过指定位置索引的元素，索引0位于表的头部，size()-1位于表中的尾部，而size()的值可以表示为若新增数据要放置的位置。</p>
<p>&emsp;&emsp;List ADT有两种流行的实现方式：ArrayList、LinkedList；ArrayList类提供了一种可动态改变容量的数组实现，使用ArrayList的优点在于，对get和set的调用花费的时间都为O(1)。其缺点则是新增数据和删除现有数据消代价非常昂贵，除非变动都是在ArrayList的末端进行。LinkedList类则提供了List的双向链表实现。使用LinkedList的优点在于添加和删除元素开销都很小，加入要变动的位置的索引都是已知的，我们就可以在要变动的元素位置的上一个元素和下一个元素的指针改动即可。LinkedList更提供了一些特殊的方法：addFirst和removeFirst、addList和removeList等有效的添加和删除链表两端的数据。使用LinkedList的缺点是它不容易作索引，因此对get的调用代价很大，除非调用非常接近链表的两端。</p>
<p>我们来编写一个方法对List添加一些数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeList1</span><span class="params">(List&lt;Integer&gt;lst,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        lst.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这段代码无论ArrayList还是LinkedList作为参数被传递，makeList1的运行的时间都是O(N)，因为对add的每次调用都是表的末端进行的从而都花费相同的时间。但是如果我们通过在表的前端添加数据来构建一个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeList2</span><span class="params">(List&lt;Integer&gt;lst,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        lst.add(<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在makeList2方法传递ArrayList与传递LinkedList的所消耗的时间就大有不同了，对于LinkedList的消耗的时间依然是O(N)，而ArrayList因为是前端添加数据所以每次添加都要原有的所有数据都要往后移动，这样ArrayList所消耗的时间是巨大的O(N*N)；</p>
<p>我们再来编写一个方法来计算表中所有数据的和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(List&lt;Integer&gt; lst)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lst.size()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        total += lst.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里ArrayLisy运行的时间是O(N),但对于LinkedList每次相加都要遍历链表找到对应i位置的元素，其运行时间则是O(N*N)。如果要是使用一个增强的for循环，anemic它对任意List的运行时间都是O(N),因为迭代器将有效地从一项到下一项推进。</p>
<p>&emsp;&emsp;在AarrayList中有一个容量的概念，它表示基础数组的大小。在需要的时候，ArrayList将自动增加其容量以保证它至少有表的大小。如果该大小早期估计存在，那么ensureCapacity可以设置容量为一个足够大的容量以避免数组容量以后的扩展。再有，trimToSize可以在所有的ArrayList添加操作完成之后使用以避免浪费空间。</p>
<blockquote>
<p><font size = 3>remove方法对LinkedList类的使用</font></p>
</blockquote>
<p>&emsp;&emsp;这里我们有一个LinkedList的表，里面存储着{4，5，6，7，8}，如果我们想构建一个方法，删除表中的偶数元素该如何去做？</p>
<ul>
<li><p>构建一个包含原表中所有基数的表，然后清空原有表</p>
</li>
<li><p>在原有的表中直接删除偶数元素</p>
</li>
</ul>
<p>&emsp;&emsp;我相信都会选择后者这种干净的方法，直接在原有表中删除偶数元素。如果对于ArrayList这是一个消耗非常巨大的操作，因为每一次删除都要移动数组中原有元素，但是对于LinkedList将会非常简单，在我们遍历链表的时候直接删除遍历到的偶数元素即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeEvensVer1</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;list.size()&gt;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.get(i)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这段代码很显然是一种失败的算法，在前面我们已经说到LinkedList对get调用的效率不高，所以这里删除元素的效率依然是低的，因为要达到i的位置代价是昂贵的。那么我们来换一种写法，使用迭代器来删除我们想删除的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeEvensVer2</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Integer x : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            list.remove(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这时我们不是用get，而是使用迭代器一步步遍历该表，这样是高效率的。这段代码看是似天衣无缝，实则更糟糕！我们使用Collection的remove方法来删除一个偶数的元素，这时不是高效率的，因为remove方法啊必须再次搜索该项，而且我们运行这个程序会发现程序会参数一个异常，因为当一个元素被删除时，表的结构就发生了改变，由增强for循环所使用的基础迭代器是不合法的！</p>
<p>吸取了上面两种方案的教训我们来继续改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeEvensVer3</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; itr = list.Iterator();</span><br><span class="line">    <span class="keyword">while</span>(itr.hasNext())&#123;</span><br><span class="line">        <span class="keyword">if</span>(itr.next()%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            itr.remobe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在迭代器找到一个偶数元素之后，使用迭代器来删除这个它刚看到的值。对与一个LinkedList，对该迭代器的remove方法的调用花费的时间很小，因为该迭代器位于要被删除的节点或在其附近。但是对于ArrayList，即使迭代器位于需要被删除元素的位置，remove方法任然是昂贵的，因为数组务必要移动！</p>
<blockquote>
<p><font size = 3>关于ListIterator接口</font></p>
</blockquote>
<p>&emsp;&emsp;ListIterator扩展了List的Iterator的功能。方法orevious和hasPrevious使得对表从后向前的功能遍历得以完成。add方法将一个新的元素以当前位置放入表中，当前元素的概念通过把迭代器看作是对next的调用所给出的项和对previous的调用所给出的元素之间而抽象出来的。</p>
<p><img src="https://i0.hdslb.com/bfs/album/b5f011191520d0f8912c8b6519b26fc3cefca961.png"></p>
<p>&emsp;&emsp;如图，a 正常起始点：next 返回5，previous是非法的，而add则把项放在5前面；b next 返回8，previous返回5，而add则把项添加在5和8的中间；c next 是非法的，previous返回9，而add则放在9的后面。</p>
<blockquote>
<p><font size = 3>迭代器、java嵌套类和内部类</font></p>
</blockquote>
<p>&emsp;&emsp;ArrayListIterator使用了一个复杂的Java结构，叫作内部类。显然该类在MyArrayList类内部被声明，这是多种语言支持的特性。然而，Java中的内部类更具有更微妙的性质！</p>
<p>&emsp;&emsp;为了了解内部类是如何工作的，下面代码描绘了迭代器的思路，不过代码由欠缺，使ArrayListIterator称为一个顶级类。我们只着重讨论MyArrayList的数据域、MyArrayList中的Iterator方法以及ArrayListIterator类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">AnyType</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">AnyType</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> theSize;</span><br><span class="line">    <span class="keyword">private</span> AnyType [] theItems;</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayListIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">AnyType</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ont current = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current &lt; size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnyType <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> theItems[current++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这是迭代器1号版本，但是不能使用迭代器是一个顶级类并存储当前位置。它不能使用因为theItems和size()不是ArrayListIterator类的一部分。ArrayListIterator是泛型类，他存储当前位置，程序在next方法中试图使用当前位置作为下标访问元素然后将当前位置向后推进。注意，如果arr是一个数组，则arr[inx++]对数组使用idx，然后向后推进idx。操作++在此次存在问题。我们这里使用的是一个**后缀++<strong>操作，此时的++实在idx之后进行的。但在</strong>前缀++**操作中，arr[++idx]先推进idx然后在使用新的idx作为数组元素的下标。上述代码中存在的问题在于，theItesm[current++]是非法的，因为theItems不是ArrayListIterator的一部分；它是MyArrayList的一部分，因此程序根本没有意义。jk7</p>
<p>接下来我们来解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">AnyType</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">AnyType</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> theSize;</span><br><span class="line">    <span class="keyword">private</span> AnyType[] theItems;</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;AnyType&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayListIterator&lt;AnyType&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">AnyType</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> MyArrayList&lt;AnyType&gt; theList;</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayListIterator</span><span class="params">(MyArrayList&lt;AnyType&gt; list)</span></span>&#123;</span><br><span class="line">        theList=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current &lt; theList.size(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnyType <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> theList.theItems[current++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面代码中是一种简单的解决方案，不过他还是有缺点，但是以更微笑的方式呈现。我们通过让迭代器存储MyArrayList的引用来解决迭代器中没有数组的问题。这个引用时第二个数据域，时通过ArrayListIterator的一个新的单参数构造器而被初始化的。既然有一个MyArrayList的引用，那么就可以访问包含于MyArrayList中的数据域。</p>
<p>&emsp;&emsp;这段代码的问题在于，theItems是MyArrayList中私有域，而由于ArrayListIterator是一个不同的类，因此在next方法中访问theItems是非法的。最简单的修正办法就是改变theItems在MyArrayList中的可见性。</p>
<p>我们再来看一种解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">AnyType</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">AnyType</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> theSize;</span><br><span class="line">    <span class="keyword">private</span> AnyType[] theItems;</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;AnyType&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayListIterator&lt;AnyType&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListIterator</span>&lt;<span class="title">AnyType</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">private</span> MyArrayList&lt;AnyType&gt; theList;</span><br><span class="line">   		 ....</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="title">ArrayListIterator</span><span class="params">(MyArrayList&lt;AnyType&gt; list)</span></span>&#123;</span><br><span class="line">        	theList=list;</span><br><span class="line">    	&#125;</span><br><span class="line">   		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">       	 	<span class="keyword">return</span> current &lt; theList.size(); </span><br><span class="line">   	    &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> AnyType <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        	<span class="keyword">return</span> theList.theItems[current++];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种方案能够正确运行：使ArrayListIterator为<strong>嵌套类</strong>。当我们让ArrayListIterator为一个嵌套类时，该类将被放入另一个类的内部，这个类就被叫作<strong>外部类</strong>。我们必须用static来表示它是嵌套的；若无static，将得到一个内部类，这有时候好，有时候也不好。嵌套类时许多编程语言的典型的而类型。注意，嵌套类可以被设计成private，这很好，因为此时该嵌套类除了能够被外部类MyArrayList访问外，其它是不可访问的。更重要的是，因为嵌套类被认为是外部类的一部分，所以不存在产生不可见的问题。</p>
<p>&emsp;&emsp;我们既然有了嵌套类，那么就可以讨论内部类。嵌套类的问题在于，在我们的原始设计中，当编写theItems而不引用其所在的MyArrayList在被引用其所在的MyArrayList的时候，代码看起来还可以，也似乎有意义，但却是无效的，因为编译器不可能计算出那个MyArrayList在被引用，这恰恰是内部类要求我们所要做的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">AnyType</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">AnyType</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> theSize;</span><br><span class="line">    <span class="keyword">private</span> AnyType[] theItems;</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;AnyType&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayListIterator&lt;AnyType&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="class"><span class="keyword">class</span> <span class="title">ArrayListIterator</span>&lt;<span class="title">AnyType</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="title">ArrayListIterator</span><span class="params">(MyArrayList&lt;AnyType&gt; list)</span></span>&#123;</span><br><span class="line">        	theList=list;</span><br><span class="line">    	&#125;</span><br><span class="line">   		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">       	 	<span class="keyword">return</span> current &lt; theList.size(); </span><br><span class="line">   	    &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> AnyType <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        	<span class="keyword">return</span> theList.theItems[current++];</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">            MyArrayList.<span class="keyword">this</span>.remove(--current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先，ArrayListIterator是隐式的泛型类，因为它现在依赖于MyArratList，而后者是泛型的；其次，theList没有了，我们用size()和theItems[current++]做为MyArrayList.this.size()和MyArrayList.this.theItems[current++]的简记符。theList作为数据成员，它的取出也删除了相关的构造器，因此程序又变成最开始的版本。</p>
<p>&emsp;&emsp;我们可以通过调用MyArrayList和remove来实现迭代器的remove方法。由于迭代器的remove可能于MyArrayList的remove冲突，因此我们必须使用MyArrayList.this.remove。</p>
<p>&emsp;&emsp;内部类为Java程序员带来语法上的便利。他们不需要编写任何Java代码，但是他们在语言中出现使Java程序员以自然的方式编写程序，而编译器则编写使用内部类对像和外部类对象相关联所需要的附加代码。</p>
<h2 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h2><h3 id="3-1-栈模型"><a href="#3-1-栈模型" class="headerlink" title="3.1 栈模型"></a>3.1 栈模型</h3><p>&emsp;&emsp;<strong>栈</strong>(stack)使限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作<strong>栈顶</strong>(top)。对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者相当于是删除最后插入的元素。最后插入的元素可以使用top例程在pop之前进行考查。对空栈进行的pop或top一般认为是栈ADT中的一个错误。另一个方面，当运行push时时间用尽是一个实现限制，但不是ADT错误。</p>
<p>&emsp;&emsp;栈有时又叫作LIFO(先进后出)表。如下图，1在栈的底部，1是先进如栈中，然后紧接着2，3，4，…. ，7，7在栈的顶端，这时只能对7进行操作。如想要除以6则要先等7出栈，6称为栈的顶部元素才可以对6操作，如果像要对1进行操作，则要依次7，6，5，…，2，等出栈后，1称为栈顶，方可操作1 。</p>
<p><img src="https://i0.hdslb.com/bfs/album/42e4c77073917fc3b058635ba192c874559a9643.png"></p>
<h3 id="3-2-栈的实现"><a href="#3-2-栈的实现" class="headerlink" title="3.2 栈的实现"></a>3.2 栈的实现</h3><p>&emsp;&emsp;由于栈式一个表，因此任何实现表的方法都能实现栈。显然，ArrayList和LinkedList都支持栈操作；99%的时间他们都是最合理的原则。偶尔设计一种特殊目的实现可能会更快。因为栈操作时常数时间操作，所以，除非在非常独特的环境下，这是不能可能产生任何明显的改进的。对于这些特殊的时机，有两种流行的实现方法，一种方法使用链式结构，而另一种发发则是使用数组。</p>
<blockquote>
<p><font size = 3>栈的链表实现</font></p>
</blockquote>
<p>&emsp;&emsp;栈的第一种实现方法是使用单链表。通过在表的顶端插入元素来实现push，通过删除表顶端的元素实现pop。top操作知识考查表顶端元素并返回它的值。优势pop操场和top操场合二为一。</p>
<blockquote>
<p><font size = 3>栈的数组实现</font></p>
</blockquote>
<p>&emsp;&emsp;数组方式实现避免了链而且可能是更流行的解决方案，与每个栈相关联的操作是theArray和topOfStack，对于空栈它是-1.如果将某个元素推入栈中，我们使topOfStack增1然后theArray[topOfStack]=x。如果像删除栈中元素。我们只需要把theArray[topOfStcak]返回，然后使topOfStack减1 。</p>
<h2 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h2><h3 id="4-1-队列模型"><a href="#4-1-队列模型" class="headerlink" title="4.1 队列模型"></a>4.1 队列模型</h3><p>&emsp;&emsp;像栈一样，<strong>队列</strong>(queue)也是表。然而不同的是，使用队列时插入在一段进行，而删除则在另一端进行。队列的基本操作时**enqueue(入队)<strong>，它是在表的末端插入一个元素，而</strong>dequeue(出队)**则是在表的开头删除一个元素。它就像我们排队买票，买完票的人从前面离开队伍，后续来的人都要在队伍的后面排序。</p>
<p><img src="https://i0.hdslb.com/bfs/album/dc873865a5bf92ab81ce8f1266be3f248793998f.png"></p>
<h3 id="4-2-队列的实现"><a href="#4-2-队列的实现" class="headerlink" title="4.2 队列的实现"></a>4.2 队列的实现</h3><blockquote>
<p><font size = 3>队列的链表实现</font></p>
</blockquote>
<p>&emsp;&emsp;如同栈的情形一样，队列的任何表的实现都是合法的。像栈一样，对于每一种操作，链遍实现和数组实现都是快速的O(1)运行时间，队列的链表实现时简单直接的，而且不需要双向链遍，我们只需要添加元素在链表的一段，而删除元素在链表的另一端即可。</p>
<blockquote>
<p><font size = 3>队列的数组实现</font></p>
</blockquote>
<p>&emsp;&emsp;对于每一个队列数据结构，我们保留一个数组theArray以及位置front和back，它们代表队列的两端。除此之外，我们还要记录队列中的元素个数currentSize。下图表示一个位于数组中间位置的队列。</p>
<p><img src="https://i0.hdslb.com/bfs/album/0a3025a872e597954210f58e8915339728f3b014.png"></p>
<p>&emsp;&emsp;如果有一个元素要入队，我们让currentSize和back加一，然后把要添加的数据放置到theArray[back]的位置，如果一个元素要出队，我们只需要将theArray[font]返回，currentSize减一，font加一即可。但是这个队列存在一个很明显的问题的，最多经过10次入队后这个队列似乎是满了的，因为经过10次入栈后不管有没有元素出栈，back的下标都是数组的最后一个下标，而这时再有元素入栈back+1这个位置是不存在的，但是这个数组的前端还是有空间的，如下图所示：</p>
<p><img src="https://i0.hdslb.com/bfs/album/b5edba33a4e894f68ae7841a376e3341c54ed32b.png"></p>
<p>&emsp;&emsp;这种问题实际由一个很简单的解决方案，就是只要font或back到达数组的末端，它就由绕回开头。比如由一个10个空间的数组，它的下标为0~9，当font或back到达9后再次有元素要入队或者出队，它们的值就从0开始。这也叫做<strong>循环数组的实现</strong>。实现回绕需要附加的代码时极小的，不过它可能使运行时间加倍。</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>&emsp;&emsp;本篇博客描述了一些ADT的概念，并且使用三种最常见的抽象数据类型阐述了这种概念。这是我根据一本数据结构与算法的数总结下来的，希望刷到的小伙伴可以对你有些许的帮助，作为一个小白，我也是刚开始学习数据结构与算法，如果有宝贵的意见可以在本站的右上角进行留言。</p>
</div><div class="tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="fa fa-tag"></i>数据结构</a></div><div class="post-nav"><a class="pre" href="/2020/08/13/%E5%85%B3%E4%BA%8Einput%E4%B8%AD%E7%9A%84disabled%E5%B1%9E%E6%80%A7/">关于input中的disabled属性</a><a class="next" href="/2020/08/10/Redis%20%E4%B8%8A/">长达数万子的Redis大总结（上）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JWT/">JWT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MyBatis/">MyBatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shiro/">Shiro</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/json/">json</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JWT/" style="font-size: 15px;">JWT</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">笔记</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97/" style="font-size: 15px;">异常日志</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/07/12/MySQL%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">最详细的MySql配置文件详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/07/shiro(%E4%BA%94)%E6%95%B4%E5%90%88SpringBoot/">Shiro入门(五)：整合SpringBoot</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/05/shiro(%E5%9B%9B)%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Shiro入门(四)：认证源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/03/shiro(%E4%B8%89)%E8%AE%A4%E8%AF%81/">Shiro入门(三)：授权</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/03/shiro(%E4%BA%8C)%E8%87%AA%E5%AE%9A%E4%B9%89Reaml%E4%B8%8E%E5%8A%A0%E5%AF%86/">Shiro入门(二)：自定义Reaml与加密</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/02/shiro(%E4%B8%80)%E6%8E%88%E6%9D%83/">Shiro入门(一)：授权</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/19/Vue%E8%BF%9B%E9%98%B6/">Vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/19/JWT%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">JWT快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/16/Leetcode-01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/">Leetcode-01-两数之和</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/16/Vue%E5%85%A5%E9%97%A8/">Vue-入门</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">岳争.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>